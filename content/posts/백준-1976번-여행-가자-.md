+++
date = "2018-10-04T04:17:35+00:00"
title = "백준 1976번 여행 가자 "

+++
문제 출처

([https://www.acmicpc.net/problem/1976](https://www.acmicpc.net/problem/1976 "https://www.acmicpc.net/problem/1976"))

이 문제도 disjoint set의 가장 기초적인 문제이다.

만약 1 -> 2 -> 3을 통해 가는 방법을 살펴 볼 때

1 -> 2로 가야하고 2 -> 3 로 가야한다.

즉, 2의 출발점은 1이 되고 3의 출발점은 2가 된다.

결국엔 3의 맨 처음 출발지는 2를 오기전 1이 된다.

즉 도착지에서 출발점이 동일한 선상에 있는지 확인하는 문제이다.

트리로 표현 했을 때

1

2

3

이런 식으로 될 것이다. 해당 경로의 트리의 루트가 같은지 물어보는 문제이다.

#### 최종코드 

    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.*;
    public class Main {
     	static int parent[];
     	static int rank[];
     	public static void main(String[] args) throws NumberFormatException, IOException {
     		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
     		int city = Integer.valueOf(br.readLine());
     		int n = Integer.valueOf(br.readLine());
     		parent = new int [city+1];
     		rank = new int[city+1];
     		
     		for(int i=1; i<=city; i++) {
     			parent[i] = i;
     			rank[i] = 0;
     		}
     		String line[];
     		for(int i=1; i<=city; i++) {
     			line = br.readLine().split(" ");
     			for (int k=1; k<=city; k++) {
     				if(Integer.valueOf(line[k-1]) == 1) {
     					union(i,k);
     				}
     			}
     		}
     		
     		line = br.readLine().split(" ");
     		boolean check = false;
     		int checking = find(Integer.valueOf(line[0]));
     		for(int i=1; i<line.length; i++) {
     			if(checking != find(Integer.valueOf(line[i]))) {
     				check = true; 
     				break;
     			}
     		}
     		
     		if(check)
     			System.out.println("NO");
     		else
     			System.out.println("YES”);
    
     	}
     	
     	public static int find(int x) {
     		if(x == parent[x])
     			return x;
     		else return parent[x] = find(parent[x]);
     	}
     	
     	public static void union(int p, int q) {
     		p = find(p);
     		q = find(q);
     		
     		if(p == q)
     			return;
     		
     		if(rank[p] < rank[q])
     			parent[p] = q;
     		else {
     			parent[q] = p;
     		}
     		
     		if(rank[p] == rank[q])
     			rank[p]++;
     		
     	}
    }