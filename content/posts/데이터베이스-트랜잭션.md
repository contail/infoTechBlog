+++
date = "2018-10-19T15:53:20+00:00"
title = "[데이터베이스] 트랜잭션"

+++
##### 데이터베이스에서 하나의 논리적인 실행단계를 "트랜잭션" 이라고한다.

은행에서 계좌이체를 트랜잭션이라고 할 수 있다. 이러한 트랜잭션이 안전하게 이루어지기 위해서는 ACID가 지켜져야 한다.

* Atomicity (원자성)

  > 은행에서 계좌이체를 할 때 돈을 보내는 계좌에서는 돈이 차감이 되었지만, 받는 사람의 걔좌에서는 입금이 되지 않으면 안된다.
  >
  > 이처럼 처음부터 끝까지 작업이 실패하면 안되도록 하는 것이다.
* Consistency(일관성)

  > 트랜잭션이 성공되면 언제나 일관성 있는 데이터베이스 상태로 유지되어야 한다. 트랜잭션 전, 후 데이터베이스가 정해논 제약을 어겨서는 안된다.
* Isolation(고립성)

  > 트랜잭션 수행시 다른 트랜잭션의 연산작업이 끼어들지 못하도록 막는 역할이다. 즉, 각 트랜잭션끼리 영향을 끼쳐서는 안된다.
* Durability(지속성)

  > 트랜잭션을 성공적으로 마치면 그 결과가 정확히, 영구적으로 반영이 되어야 한다.

###### 이런 4가지 원칙이 있습니다. 이 중에서 ‘고립성’에 대한 약간의 이슈가 있습니다.

고립성은 다른 트랜잭션이 끼어들지 못하게 순차적으로 실행하게 됩니다. 그럴 경우 동시성이 이루어 지지 못하기 때문에 속도저하와 같은 현상이 발생 할 가능성이 있습니다.

반대로 병렬처리를 하게 되면 데이터의 무결성이 깨질 수 있습니다.

###### 격리성 관련 문제점

* Dirty Read

  > * 한 트랜잭션(T1) 이 데이터를 ‘A’에서 ‘B’로 변경했고 커밋을 안한 상태, 다른 트랜잭션이(T2) 해당 데이터를 읽게 되면?
  > * T2가 가지는 데이터는 B가 되지만, 만약 T1가 커밋을 안할 경우 데이터가 꼬일 수 있다.
  > * T1 데이터 변경 -> T2 read -> T1 non commit
* Non- Repeatable Read

  > * 한 트랜잭션(T1)이 데이터를 Read. 다른 트랜잭션(T2)가 데이터에 접근하여 값을 변경하거나 삭제하는 경우
  > * 그 후 T1이 다시 그 값을 Read하는 경우 변경된 데이터나 삭제된 데이터를 찾게된다.
  > * 즉 한 트랜잭션 안에서 같은 쿼리를 두 번 수행할 때, 다른 트랜잭션의 수정이나 삭제로 인해 쿼리의 결과가 다른경우
* Phantom Read

  > * 트랜잭션(T1)이 특정 Data를 Read 했다. 다른 트랙잭션(T2)가 해당 데이터의 일부를 삭제 / 변경을 했다.
  > * 다시 T1이 데이터를 조회하게되면 삭제 /변경된 데이터가  조회 / 누락된다.
  > * 즉 한 트랜잭션에서 두 번의 쿼리를 수행 할 때, 다른 트랜잭션의 입력으로 인해 첫 번째에 없었던 레코드가 두번째에서는 생기는 현상

###### 즉 이러한 문제점들을 Trade -off를 하면서 해결하고자 4가지의 격리수준으로 나뉘게 된다.

내려갈수록 격리수준이 높아져 언급된 문제점들은 해결 할 수 있지만, 성능이 떨어지게 된다. 따라서 상황에 따라(?) 적절하게 사용해야한다.

##### 격리수준

* Read Uncommited

  > * 아직 커밋되지 않은 데이터를 읽을 수 있다.
  > * Dirty Read, Non- Repeatable Read, Phantom Read 문제가 발생 할 수 있다.
* Read Commited

  > * 커밋이 완료된 데이터만 읽을 수 있다.
  > * Non- Repeatable Read, Phantom Read 문제가 발생 할 수 있다.
* Repeatable Read

  > * 트랜잭션을 읽은 데이터를 해당 트랜잭션이 종료될 때까지 다른트랜잭션의 수정이나 삭제가 가능하지 않도록 한다.
  > * Phantom Read 문제가 발생 할 수 있다. (새로운 입력이 가능함으로)
* Serailizable(가장 완벽한 격리)

  > * 해당 트랜잭션이 종료 될 때까지 다른 트랜잭션에 의한 새로운 레코드가 삽입이 안되도록 한다.
  > * 모든 경우에서 커버가 가능.